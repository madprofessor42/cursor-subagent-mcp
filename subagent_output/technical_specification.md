# Техническое задание: Динамическое создание агентов через MD файлы

## 1. Общее описание

### 1.1. Краткое описание задачи

Реализовать функциональность динамического создания агентов для мультиагентной системы разработки через MD файлы. Пользователи должны иметь возможность создавать новых агентов, размещая MD файлы с промптами и метаданными в указанной директории. Система должна автоматически обнаруживать, парсить и регистрировать таких агентов при старте MCP сервера.

### 1.2. Цель разработки

- Упростить процесс добавления новых агентов без изменения кода
- Позволить пользователям создавать кастомных агентов для специфических задач
- Сохранить совместимость с существующей системой встроенных агентов
- Обеспечить автоматическое обновление промпта оркестратора с информацией о новых агентах

### 1.3. Связь с существующей системой

**Текущая архитектура:**
- Агенты определяются статически в `agents.yaml`
- Промпты хранятся в `agents-master/*.md`
- Конфигурация загружается через `config.py` (singleton)
- Промпт оркестратора в `agents-master/01_orchestrator.md` содержит статический список агентов
- Агенты вызываются через `invoke_subagent()` из `tools/invoke.py`

**Изменения:**
- Добавление поддержки динамических агентов из MD файлов
- Расширение `config.py` для загрузки динамических агентов
- Обновление `orchestration.py` для включения динамических агентов в список доступных
- Автоматическое обновление промпта оркестратора (runtime или при старте)

## 2. Список юзер-кейсов

### UC-01: Создание нового агента через MD файл

**Актёры:**
- Пользователь (разработчик)
- Система (MCP сервер)
- Файловая система

**Предусловия:**
- MCP сервер не запущен или будет перезапущен
- Пользователь имеет доступ к файловой системе проекта
- Переменная окружения `CURSOR_AGENTS_DIR` установлена (опционально, для кастомной папки)

**Основной сценарий:**
1. Пользователь создаёт MD файл в папке с промптами агентов. Путь к папке определяется переменной окружения `CURSOR_AGENTS_DIR` (если установлена) или используется папка по умолчанию `agents-master/` относительно корня проекта
2. Пользователь заполняет MD файл в следующем формате:
   - Секция `## METADATA` содержит метаданные агента:
     - `role`: роль агента (любая строка, система преобразует в нужный формат)
     - `name`: имя агента
     - `description`: описание агента
     - `default_model`: модель по умолчанию (опционально)
   - Секция `## INVOCATION CONDITIONS` описывает, когда вызывать этот агент (информация для промпта оркестратора)
   - Секция `## PROMPT` содержит промпт самого агента (передаётся при вызове через `invoke_subagent`)
3. Пользователь запускает или перезапускает MCP сервер
4. Система при инициализации заново сканирует указанную папку на наличие MD файлов (все `.md` файлы в корневой папке, без рекурсии). Система НЕ запоминает предыдущее состояние файлов и НЕ отслеживает изменения
5. Система парсит каждый найденный MD файл:
   - Извлекает метаданные из секции `## METADATA` (алгоритм описан в разделе 8.1)
   - Извлекает условия вызова из секции `## INVOCATION CONDITIONS` (алгоритм описан в разделе 8.1)
   - Извлекает промпт из секции `## PROMPT` (алгоритм описан в разделе 8.1)
   - Преобразует роль агента в стандартизированный формат (алгоритм описан в разделе 5.2)
   - Валидирует обязательные поля (роль, имя, описание, промпт)
6. Система проверяет конфликты ролей:
   - Сначала проверяются конфликты между динамическими агентами (при обнаружении дубликатов преобразованных ролей)
   - Затем проверяются конфликты между динамическими и встроенными (из `agents.yaml`) агентами
   - При обнаружении конфликта система НЕ запускается и выводит ошибку в консоль
7. Если обнаружен конфликт ролей между динамическими агентами:
   - Система выводит ошибку: "Role conflict detected: role 'X' is used by multiple dynamic agents in files: file1.md, file2.md"
   - Система НЕ запускается
8. Если обнаружен конфликт ролей между динамическим и встроенным агентом:
   - Система выводит ошибку: "Role conflict detected: role 'X' is already used by a built-in agent"
   - Система НЕ запускается
8. Если конфликтов нет, система добавляет найденных агентов в runtime конфигурацию (только в памяти, не изменяет `agents.yaml`)
9. Система сохраняет все системные промпты и извлечённые данные (метаданные, промпты агентов) в переменные/объекты конфигурации при старте сервера
10. Система обновляет промпт оркестратора в памяти при каждом вызове `get_orchestration_guide()`, добавляя информацию о динамических агентах в единый список (без различий между встроенными и динамическими)
11. Система делает новых агентов доступными через `invoke_subagent()`
12. При вызове агента через `invoke_subagent()` передаётся ТОЛЬКО секция `## PROMPT` (без METADATA и INVOCATION CONDITIONS), извлечённая согласно алгоритму из раздела 8.1
13. Пользователь может вызвать нового агента через `invoke_subagent(agent_role="новая_роль", ...)`

**Альтернативные сценарии:**

**А1: Переменная окружения не установлена (на шаге 1)**
1. Система использует папку по умолчанию: `agents-master/`
2. Продолжение основного сценария с шага 3

**А2: MD файл содержит невалидные метаданные (на шаге 5)**
1. Система логирует ошибку с указанием файла и проблемы
2. Система пропускает этот файл и продолжает обработку остальных
3. Система выводит предупреждение при старте о пропущенных файлах
4. Продолжение основного сценария для валидных файлов

**А3: Конфликт имён ролей между динамическими агентами (на шаге 6)**
1. Система обнаруживает, что несколько динамических агентов имеют роли, которые преобразуются в одинаковую роль
2. Система НЕ запускается и выводит ошибку в консоль: "Role conflict detected: role 'X' is used by multiple dynamic agents in files: file1.md, file2.md"
3. Пользователь должен исправить конфликт (изменить роль одного из конфликтующих агентов)
4. Конец сценария (сервер не запущен)

**А3.1: Конфликт имён ролей между динамическим и встроенным агентом (на шаге 6)**
1. Система обнаруживает, что роль динамического агента (после преобразования) совпадает с ролью из `agents.yaml`
2. Система НЕ запускается и выводит ошибку в консоль: "Role conflict detected: role 'X' is already used by a built-in agent"
3. Пользователь должен исправить конфликт (изменить роль динамического агента или удалить встроенного агента)
4. Конец сценария (сервер не запущен)

**А4: MD файл не содержит обязательных полей (на шаге 5)**
1. Система определяет отсутствие обязательного поля (например, роль или промпт)
2. Система логирует ошибку с указанием отсутствующего поля
3. Система пропускает этот файл
4. Продолжение основного сценария для валидных файлов

**А7: Пустое значение обязательного поля (на шаге 5)**
1. Система проверяет значение обязательного поля после trim (удаление пробелов в начале и конце)
2. Если значение пустое (после удаления пробелов), система логирует ошибку: "Empty value for required field 'role' in METADATA section of file: путь_к_файлу"
3. Система пропускает этот файл
4. Продолжение основного сценария для валидных файлов

**А5: Путь к папке не существует (на шаге 4)**
1. Система проверяет существование указанной папки
2. Система логирует предупреждение о несуществующей папке
3. Система использует папку по умолчанию `agents-master/` (если она существует)
4. Продолжение основного сценария

**А6: Папка с агентами пуста (на шаге 4)**
1. Система сканирует папку и не находит MD файлов (папка существует, но пуста)
2. Система логирует информационное сообщение: "No dynamic agents found in directory: путь"
3. Система продолжает работу только с встроенными агентами из `agents.yaml`
4. Промпт оркестратора содержит только встроенных агентов
5. Продолжение основного сценария (система успешно запускается)

**Постусловия:**
- Новый агент зарегистрирован в системе
- Агент доступен через `invoke_subagent()`
- Промпт оркестратора обновлён с информацией о новом агенте
- Все ошибки залогированы

**Критерии приёмки:**
- ✅ Пользователь может создать агента через MD файл без изменения кода
- ✅ Система автоматически обнаруживает все `.md` файлы в корневой папке (без рекурсии по вложенным папкам) при старте сервера
- ✅ При каждом старте сервера система заново парсит все MD файлы без отслеживания предыдущего состояния
- ✅ Система корректно парсит секции METADATA, INVOCATION CONDITIONS и PROMPT из MD файла согласно алгоритму из раздела 8.1
- ✅ При обнаружении конфликта ролей сервер не запускается и выводит понятное сообщение об ошибке с указанием конфликтующих ролей и файлов
- ✅ Новый агент доступен через `invoke_subagent()` сразу после старта (используется преобразованная роль)
- ✅ При старте сервера все системные промпты и извлечённые данные сохраняются в переменные/объекты конфигурации
- ✅ Промпт оркестратора обновляется в памяти при каждом вызове `get_orchestration_guide()` согласно механизму из раздела 7.1 и содержит информацию о новом агенте в едином списке (таблица markdown)
- ✅ При вызове агента передаётся только секция PROMPT (без METADATA и INVOCATION CONDITIONS)
- ✅ Ошибки парсинга не блокируют загрузку остальных агентов
- ✅ Все ошибки логируются с контекстом (указание файла и проблемы)

---

### UC-02: Использование динамического агента

**Актёры:**
- Оркестратор (основной агент в Cursor UI)
- Система (MCP сервер)
- Динамический агент (через cursor-agent CLI)

**Предусловия:**
- Динамический агент успешно зарегистрирован (UC-01 выполнен)
- MCP сервер запущен
- `cursor-agent` CLI установлен и доступен

**Основной сценарий:**
1. Оркестратор вызывает `get_orchestration_guide()` для получения списка доступных агентов
2. Система возвращает список агентов, включая динамических (объединённый список из `agents.yaml` и MD файлов)
3. Оркестратор видит нового агента в списке с его описанием
4. Оркестратор вызывает `invoke_subagent(agent_role="роль_динамического_агента", task="задача", cwd="...")`
5. Система находит агента в конфигурации (динамического или встроенного)
6. Система загружает промпт из секции `## PROMPT` соответствующего MD файла (без METADATA и INVOCATION CONDITIONS), извлечённый согласно алгоритму из раздела 8.1
7. Система вызывает `cursor-agent` CLI с загруженным промптом
8. Динамический агент выполняет задачу и возвращает результат
9. Система возвращает результат оркестратору
10. Оркестратор получает результат работы динамического агента

**Альтернативные сценарии:**

**А1: Агент не найден (на шаге 5)**
1. Система проверяет наличие агента в конфигурации
2. Система возвращает ошибку: "Unknown agent role: 'роль'. Available: ..."
3. Оркестратор получает ошибку и может сообщить пользователю

**А2: Промпт файл не найден (на шаге 6)**
1. Система пытается загрузить промпт из MD файла
2. Система обнаруживает, что файл не существует (был удалён после регистрации)
3. Система возвращает ошибку: "Prompt file not found: путь_к_файлу"
4. Система логирует ошибку
5. Оркестратор получает ошибку

**Постусловия:**
- Динамический агент выполнил задачу (или вернул ошибку)
- Результат передан оркестратору
- Все действия залогированы

**Критерии приёмки:**
- ✅ Динамические агенты отображаются в списке доступных агентов
- ✅ Динамические агенты вызываются через `invoke_subagent()` так же, как встроенные
- ✅ Промпт динамического агента корректно загружается и передаётся в cursor-agent
- ✅ Результаты работы динамического агента возвращаются корректно
- ✅ Ошибки обрабатываются и логируются

---

### UC-03: Обновление существующего динамического агента

**Актёры:**
- Пользователь (разработчик)
- Система (MCP сервер)

**Предусловия:**
- Динамический агент уже создан и зарегистрирован (UC-01 выполнен)
- MCP сервер запущен

**Основной сценарий:**
1. Пользователь редактирует MD файл существующего динамического агента:
   - Изменяет метаданные в секции `## METADATA` (имя, описание, модель, роль)
   - Изменяет условия вызова в секции `## INVOCATION CONDITIONS`
   - Изменяет промпт в секции `## PROMPT`
2. Пользователь перезапускает MCP сервер
3. Система при инициализации заново сканирует папку с агентами и парсит все MD файлы (полная перезагрузка без отслеживания предыдущего состояния)
4. Система парсит обновлённый файл и извлекает новые метаданные, условия вызова и промпт согласно алгоритму из раздела 8.1
5. Система проверяет конфликты ролей согласно порядку из раздела 6.1
6. Если конфликтов нет, система сохраняет обновлённую конфигурацию агента в runtime (в памяти)
7. Система сохраняет все системные промпты и извлечённые данные в переменные/объекты конфигурации при старте сервера
8. Система обновляет промпт оркестратора в памяти при следующем вызове `get_orchestration_guide()` с новой информацией об агенте
9. Обновлённый агент становится доступным с новыми параметрами

**Альтернативные сценарии:**

**А1: Изменение роли агента (на шаге 1)**
1. Пользователь изменяет роль агента в MD файле
2. Пользователь перезапускает MCP сервер
3. Система при инициализации заново парсит все MD файлы
4. Система извлекает новую роль из обновлённого файла и преобразует её согласно алгоритму из раздела 5.2
5. Система проверяет конфликты ролей (сначала между динамическими агентами, затем с встроенными)
6. Если конфликта нет, агент регистрируется с новой ролью
7. Старая роль больше не существует (так как система не запоминает предыдущее состояние)
8. Агент доступен под новой ролью

**А2: MD файл стал невалидным после редактирования (на шаге 4)**
1. Система пытается распарсить обновлённый файл
2. Система обнаруживает ошибки валидации (отсутствие секций, обязательных полей)
3. Система логирует ошибку с указанием проблемы и файла
4. Система пропускает этот файл (агент не будет создан)
5. Система продолжает обработку остальных файлов

**А3: Конфликт ролей после изменения роли (на шаге 5)**
1. Пользователь изменил роль агента в секции METADATA
2. Система при проверке конфликтов обнаруживает, что новая роль конфликтует с существующим агентом
3. Система НЕ запускается и выводит ошибку в консоль
4. Пользователь должен исправить конфликт
5. Конец сценария (сервер не запущен)

**А4: Файл переименован (на шаге 3)**
1. Пользователь переименовал MD файл (например, `agent_v1.md` → `agent_v2.md`)
2. Система при инициализации заново парсит все MD файлы
3. Система не находит старый файл `agent_v1.md` (агент не будет создан)
4. Система находит новый файл `agent_v2.md` и парсит его
5. Система регистрирует агента из нового файла как нового агента (не связывает со старым)
6. Если в старом файле была роль `old_role`, а в новом файле та же роль, агент будет доступен под той же ролью, но это считается новым агентом (не обновлением старого)

**Постусловия:**
- Конфигурация агента обновлена (или агент не создан при ошибке)
- Промпт оркестратора обновлён
- Изменения залогированы

**Критерии приёмки:**
- ✅ Изменения в MD файле применяются после перезапуска сервера
- ✅ При перезапуске сервера система заново парсит все MD файлы без отслеживания предыдущего состояния
- ✅ Обновлённые метаданные, условия вызова и промпт используются при вызове агента
- ✅ Промпт оркестратора обновляется в памяти при вызове `get_orchestration_guide()` и отражает актуальную информацию об агенте
- ✅ При изменении роли проверяются конфликты (сервер не запускается при конфликте)
- ✅ Ошибки валидации приводят к пропуску файла (агент не создаётся)
- ✅ Все изменения логируются
- ✅ При переименовании файла старый агент не создаётся, новый регистрируется как новый агент

---

### UC-04: Удаление динамического агента

**Актёры:**
- Пользователь (разработчик)
- Система (MCP сервер)

**Предусловия:**
- Динамический агент создан и зарегистрирован (UC-01 выполнен)
- MCP сервер запущен

**Основной сценарий:**
1. Пользователь удаляет MD файл динамического агента из папки
2. Пользователь перезапускает MCP сервер
3. Система при инициализации заново сканирует папку с агентами и парсит все MD файлы (полная перезагрузка без отслеживания предыдущего состояния)
4. Система не находит удалённый MD файл
5. Система не создаёт агента (так как файл не найден)
6. Система обновляет промпт оркестратора в памяти при следующем вызове `get_orchestration_guide()`, не включая информацию об удалённом агенте
7. Агент больше не доступен через `invoke_subagent()`

**Альтернативные сценарии:**

**А1: Попытка вызвать удалённого агента (после шага 7)**
1. Оркестратор пытается вызвать удалённого агента через `invoke_subagent()`
2. Система проверяет наличие агента в конфигурации
3. Система возвращает ошибку: "Unknown agent role: 'роль'. Available: ..."
4. Оркестратор получает ошибку

**Постусловия:**
- Агент не создан при старте сервера (так как файл не найден)
- Промпт оркестратора обновлён (не содержит информацию об удалённом агенте)
- Агент недоступен для вызова

**Критерии приёмки:**
- ✅ Удаление MD файла приводит к тому, что агент не будет создан при следующем старте сервера
- ✅ Промпт оркестратора не содержит информацию об удалённом агенте
- ✅ Попытка вызвать удалённого агента возвращает понятную ошибку
- ✅ Удаление залогировано (или не логируется, так как система не знает о предыдущем состоянии)

---

### UC-05: Совместное использование встроенных и динамических агентов

**Актёры:**
- Оркестратор
- Система (MCP сервер)
- Встроенные агенты (из agents.yaml)
- Динамические агенты (из MD файлов)

**Предусловия:**
- В системе есть встроенные агенты (из `agents.yaml`)
- В системе есть динамические агенты (из MD файлов)
- MCP сервер запущен

**Основной сценарий:**
1. Оркестратор вызывает `get_orchestration_guide()`
2. Система загружает встроенных агентов из `agents.yaml` (при старте сервера)
3. Система загружает динамических агентов из MD файлов (при старте сервера)
4. Система объединяет списки агентов (встроенные + динамические)
5. Система возвращает объединённый список оркестратору
6. Оркестратор видит все агенты (встроенные и динамические) в одном списке
7. Оркестратор может вызывать как встроенных, так и динамических агентов через `invoke_subagent()`
8. Все агенты работают одинаково, независимо от источника (встроенный или динамический)

**Примечание:**
- Изменения в `agents.yaml` требуют перезапуска сервера (как и для динамических агентов)
- При перезапуске система загружает актуальную версию `agents.yaml` и проверяет конфликты с динамическими агентами заново
- Если встроенный агент удалён из `agents.yaml`, он не будет доступен после перезапуска сервера

**Альтернативные сценарии:**

**А1: Конфликт имён ролей между динамическими агентами (на шаге 4)**
1. Система обнаруживает, что несколько динамических агентов имеют роли, которые преобразуются в одинаковую роль
2. Система НЕ запускается и выводит ошибку в консоль: "Role conflict detected: role 'X' is used by multiple dynamic agents in files: file1.md, file2.md"
3. Пользователь должен исправить конфликт перед запуском сервера
4. Конец сценария (сервер не запущен)

**А1.1: Конфликт имён ролей между динамическим и встроенным агентом (на шаге 4)**
1. Система обнаруживает, что преобразованная роль динамического агента совпадает с ролью встроенного агента
2. Система НЕ запускается и выводит ошибку в консоль: "Role conflict detected: role 'X' is already used by a built-in agent"
3. Пользователь должен исправить конфликт перед запуском сервера
4. Конец сценария (сервер не запущен)

**Постусловия:**
- Все агенты (встроенные и динамические) доступны оркестратору
- Агенты работают одинаково независимо от источника

**Критерии приёмки:**
- ✅ Встроенные и динамические агенты отображаются в едином списке без различий
- ✅ Все агенты вызываются одинаково через `invoke_subagent()`
- ✅ Нет различий в поведении между встроенными и динамическими агентами
- ✅ Конфликты имён предотвращают запуск сервера с понятным сообщением об ошибке

---

### UC-06: Настройка пути к папке с динамическими агентами

**Актёры:**
- Пользователь (разработчик)
- Система (MCP сервер)

**Предусловия:**
- MCP сервер не запущен или будет перезапущен
- Пользователь имеет доступ к настройке переменных окружения

**Основной сценарий:**
1. Пользователь устанавливает переменную окружения `CURSOR_AGENTS_DIR` с путём к папке с MD файлами агентов
2. Пользователь запускает MCP сервер
3. Система при инициализации проверяет наличие переменной окружения `CURSOR_AGENTS_DIR`
4. Система использует указанный путь для сканирования MD файлов
5. Система сканирует корневую указанную папку (без рекурсии по вложенным папкам) на наличие MD файлов
6. Система загружает найденных агентов из всех MD файлов в корневой папке

**Альтернативные сценарии:**

**А1: Переменная окружения не установлена (на шаге 3)**
1. Система не находит переменную `CURSOR_AGENTS_DIR`
2. Система использует путь по умолчанию: `agents-master/` (относительно корня проекта)
3. Продолжение основного сценария с шага 5

**А2: Указанный путь не существует (на шаге 4)**
1. Система проверяет существование указанной папки
2. Система обнаруживает, что папка не существует
3. Система логирует предупреждение о несуществующей папке
4. Система использует путь по умолчанию `agents-master/` (если он существует)
5. Если и путь по умолчанию не существует, система логирует предупреждение и продолжает работу только с встроенными агентами (как в UC-01, А6)
6. Продолжение основного сценария

**А3: Указанный путь не является директорией (на шаге 4)**
1. Система проверяет, что указанный путь является директорией
2. Система обнаруживает, что это файл, а не директория
3. Система логирует ошибку
4. Система использует путь по умолчанию `agents-master/`
5. Продолжение основного сценария

**Постусловия:**
- Система использует указанную папку (или папку по умолчанию) для загрузки агентов
- Все действия залогированы

**Критерии приёмки:**
- ✅ Переменная окружения `CURSOR_AGENTS_DIR` корректно обрабатывается
- ✅ При отсутствии переменной используется папка по умолчанию
- ✅ Ошибки с путём обрабатываются gracefully с fallback на папку по умолчанию
- ✅ Все действия логируются

---

### UC-07: Валидация MD файлов агентов

**Актёры:**
- Система (MCP сервер)
- MD файл с агентом

**Предусловия:**
- MCP сервер запускается
- В папке с агентами есть MD файлы

**Основной сценарий:**
1. Система сканирует корневую папку с агентами (без рекурсии) и находит все MD файлы
2. Для каждого MD файла система выполняет валидацию:
   - Проверяет формат секций:
     - Секции должны быть уровня 2 (`## Заголовок`)
     - Секции должны иметь название: `## METADATA`, `## INVOCATION CONDITIONS`, `## PROMPT` (регистр не важен, case-insensitive сравнение)
     - Если найдено несколько секций с одинаковым названием, используется первая найденная
   - Проверяет наличие секции `## METADATA` с обязательными полями:
     - `role`: любая непустая строка (система сама преобразует в нужный формат)
     - `name`: имя агента
     - `description`: описание агента
     - `default_model`: опционально, валидное имя модели
   - Проверяет наличие секции `## PROMPT` с непустым содержимым (после trim)
   - Проверяет размер секции PROMPT (не должен превышать 1MB)
   - Проверяет наличие секции `## INVOCATION CONDITIONS` (опционально, но рекомендуется)
3. Если файл валиден, система регистрирует агента
4. Если файл невалиден, система логирует ошибку и пропускает файл

**Альтернативные сценарии:**

**А1: Отсутствует обязательное поле (на шаге 2)**
1. Система обнаруживает отсутствие обязательного поля в секции `## METADATA` (например, роль)
2. Система логирует ошибку: "Missing required field 'role' in METADATA section of file: agents-master/custom_agent.md"
3. Система пропускает этот файл
4. Система продолжает обработку остальных файлов

**А2: Промпт пустой или отсутствует секция PROMPT (на шаге 2)**
1. Система проверяет наличие секции `## PROMPT` в файле
2. Система обнаруживает, что секция отсутствует или промпт пустой (после trim)
3. Система логирует ошибку: "Empty or missing PROMPT section in file: agents-master/custom_agent.md"
4. Система пропускает этот файл

**А3: Отсутствует секция METADATA (на шаге 2)**
1. Система пытается найти секцию `## METADATA` в файле
2. Система обнаруживает, что секция отсутствует
3. Система логирует ошибку: "Missing METADATA section in file: agents-master/custom_agent.md"
4. Система пропускает этот файл

**А4: Секция PROMPT превышает максимальный размер (на шаге 2)**
1. Система извлекает секцию PROMPT из файла
2. Система проверяет размер извлечённой секции PROMPT
3. Система обнаруживает, что размер превышает 1MB
4. Система логирует ошибку: "PROMPT section exceeds maximum size of 1MB in file: agents-master/custom_agent.md"
5. Система пропускает этот файл

**А5: Неправильный формат секции (на шаге 2)**
1. Система пытается найти секции в файле
2. Система обнаруживает, что секция написана с неправильным уровнем заголовка (например, `### METADATA` вместо `## METADATA`)
3. Система не распознаёт секцию и считает её отсутствующей
4. Система логирует ошибку: "Missing METADATA section in file: agents-master/custom_agent.md" (или соответствующую ошибку для отсутствующей секции)
5. Система пропускает этот файл

**А6: Секция написана с опечаткой (на шаге 2)**
1. Система пытается найти секции в файле (используя case-insensitive сравнение)
2. Система обнаруживает, что секция написана с опечаткой (например, `## METADAT` вместо `## METADATA`)
3. Система не распознаёт секцию и считает её отсутствующей
4. Система логирует ошибку: "Missing METADATA section in file: agents-master/custom_agent.md" (или соответствующую ошибку для отсутствующей секции)
5. Система пропускает этот файл

**А7: Пустое значение обязательного поля в METADATA (на шаге 2)**
1. Система извлекает значение обязательного поля из секции METADATA
2. Система проверяет значение после trim (удаление пробелов в начале и конце)
3. Система обнаруживает, что значение пустое (например, `role: ` или `role:   `)
4. Система логирует ошибку: "Empty value for required field 'role' in METADATA section of file: agents-master/custom_agent.md"
5. Система пропускает этот файл

**Постусловия:**
- Валидные файлы зарегистрированы
- Невалидные файлы пропущены с логированием ошибок

**Критерии приёмки:**
- ✅ Все обязательные секции (METADATA, PROMPT) проверяются на наличие и правильный формат
- ✅ Формат секций валидируется (уровень заголовка должен быть 2, название секции распознаётся case-insensitive)
- ✅ Обязательные поля в секции METADATA (role, name, description) валидируются
- ✅ Роль может быть любой непустой строкой после trim (система преобразует в нужный формат согласно алгоритму из раздела 5.2)
- ✅ Пустые значения обязательных полей (после trim) считаются невалидными и приводят к пропуску файла
- ✅ Размер секции PROMPT проверяется (не должен превышать 1MB)
- ✅ Секция INVOCATION CONDITIONS опциональна, но рекомендуется
- ✅ Ошибки валидации логируются с контекстом (указание файла и проблемы, примеры в альтернативных сценариях)
- ✅ Невалидные файлы не блокируют загрузку остальных
- ✅ Сообщения об ошибках понятны и информативны (содержат путь к файлу и описание проблемы)

## 3. Нефункциональные требования

### 3.1. Производительность
- Загрузка динамических агентов при старте сервера не должна занимать более 2 секунд для 10 агентов
- Парсинг одного MD файла не должен занимать более 100ms
- Обновление промпта оркестратора не должно занимать более 500ms

### 3.2. Безопасность
- Валидация путей к файлам для предотвращения path traversal атак
- Проверка размера секции PROMPT (максимальный размер: 1MB) - лимит применяется к извлечённой секции PROMPT, так как она передаётся в cursor-agent CLI
- При превышении лимита файл считается невалидным и пропускается с ошибкой: "PROMPT section exceeds maximum size of 1MB in file: путь_к_файлу"
- Санитизация метаданных перед использованием

### 3.3. Масштабируемость
- Система должна поддерживать до 50 динамических агентов без деградации производительности
- Загрузка агентов должна быть параллелизуема (если потребуется в будущем)

### 3.4. Совместимость
- Обратная совместимость: существующие встроенные агенты должны работать без изменений
- Совместимость с текущим форматом `agents.yaml`
- Совместимость с текущим форматом промпта оркестратора

### 3.5. Надёжность
- Ошибки парсинга одного файла не должны влиять на загрузку остальных
- Система должна корректно обрабатывать отсутствие папки с агентами
- Система должна корректно обрабатывать пустую папку с агентами

## 4. Ограничения и допущения

### 4.1. Технические ограничения
- Динамические агенты загружаются только при старте сервера (не поддерживается hot-reload)
- Для применения изменений в MD файлах требуется перезапуск MCP сервера
- При каждом старте сервера система заново парсит все MD файлы без отслеживания предыдущего состояния
- Если файл удалён - агент просто не будет создан при следующем старте
- Если файл переименован - это считается новым агентом (старый не будет создан, так как файл не найден)
- Формат MD файла должен быть единообразным для всех динамических агентов (секции METADATA, INVOCATION CONDITIONS, PROMPT)
- Сканируются только MD файлы в корневой папке (без рекурсии по вложенным папкам)
- Динамические агенты хранятся только в runtime (в памяти), не изменяют `agents.yaml`
- При конфликте ролей сервер не запускается (требуется явное разрешение конфликта)

### 4.2. Бизнес-ограничения
- Пользователи должны понимать формат MD файла для создания агентов
- Изменения в MD файлах требуют перезапуска сервера (может быть неудобно для разработки)

### 4.3. Допущения
- Пользователи имеют доступ к файловой системе для создания/редактирования MD файлов
- Пользователи понимают структуру промптов агентов и формат MD файла с секциями (METADATA, INVOCATION CONDITIONS, PROMPT)
- Переменная окружения `CURSOR_AGENTS_DIR` устанавливается пользователем при необходимости
- Все MD файлы в корневой папке сканируются при каждом старте сервера (фильтрация происходит по наличию валидных секций)
- Система не запоминает предыдущее состояние файлов и не отслеживает изменения между запусками
- При переименовании файла это считается новым агентом (старый не будет создан, так как файл не найден)
- Роль агента может быть любой непустой строкой после trim (система преобразует в нужный формат согласно алгоритму из раздела 5.2)
- При вызове `invoke_subagent()` используется преобразованная роль агента
- Промпт оркестратора обновляется в памяти при каждом вызове `get_orchestration_guide()` согласно механизму из раздела 7.1 (runtime обновление, пересчёт при каждом вызове)
- Файл `01_orchestrator.md` перечитывается при каждом вызове `get_orchestration_guide()` для обработки возможных изменений
- Парсинг MD файлов выполняется согласно алгоритму из раздела 8.1 (извлечение секций по заголовкам уровня 2, регистр не важен)

## 5. Формат MD файла для динамических агентов

### 5.1. Структура файла

MD файл динамического агента должен содержать три секции:

```markdown
## METADATA

role: custom_agent
name: Кастомный агент
description: Описание агента
default_model: claude-sonnet-4-20250514

## INVOCATION CONDITIONS

Когда вызывать этот агент:
- Для задач типа X
- Когда требуется Y
- В ситуациях Z

## PROMPT

Ты — кастомный агент...

[Основной промпт агента]
```

### 5.2. Описание секций

**METADATA:**
- Формат: YAML-подобный формат с парами `ключ: значение`
- Поля записываются в формате `ключ: значение` (двоеточие с пробелом после)
- Значения могут быть многострочными (с отступами)
- Поддерживается только простой формат `ключ: значение` (без YAML-списков, без вложенных объектов)
- Обязательные поля:
  - `role` (обязательно): роль агента, любая непустая строка после trim (система преобразует в нужный формат согласно алгоритму из раздела 5.2)
  - `name` (обязательно): человекочитаемое имя агента, непустая строка после trim
  - `description` (обязательно): описание роли и назначения агента (может быть многострочным, непустое после trim)
- Опциональные поля:
  - `default_model` (опционально): модель по умолчанию для этого агента (валидное имя модели, непустая строка после trim)

**Обработка специальных символов:**
- Если значение содержит двоеточие, его нужно заключить в кавычки: `description: "Использует модель: claude"`
- Если значение содержит кавычки, используйте одинарные кавычки или экранирование: `description: 'Он сказал "привет"'`
- Многострочные значения поддерживаются с отступами (YAML-стиль с `|` или `>`)

**Примеры секции METADATA:**

**Простой пример:**
```markdown
## METADATA

role: custom_agent
name: Кастомный агент
description: Описание агента в одну строку
default_model: claude-sonnet-4-20250514
```

**Многострочное описание:**
```markdown
## METADATA

role: custom_agent
name: Кастомный агент
description: |
  Это многострочное описание агента.
  Может содержать несколько строк.
  Используется для отображения в промпте оркестратора.
default_model: claude-sonnet-4-20250514
```

**Значение с двоеточием:**
```markdown
## METADATA

role: custom_agent
name: Кастомный агент
description: "Использует модель: claude-sonnet-4-20250514 для анализа кода"
```

**Обработка пустых значений:**
- Пустые значения (после trim) считаются невалидными для обязательных полей
- Пример невалидного: `role: ` (пустое значение) или `role:   ` (только пробелы)
- Пример невалидного: `description: |` (многострочное, но пустое после trim)

**Преобразование роли агента:**

Роль из секции METADATA преобразуется в стандартизированный формат для внутреннего использования в системе. Алгоритм преобразования:

1. Приведение к нижнему регистру (lowercase)
2. Замена пробелов на подчёркивания (`_`)
3. Удаление специальных символов (остаются только буквы, цифры и подчёркивания)
4. Удаление множественных подчёркиваний подряд (замена на одно)
5. Удаление подчёркиваний в начале и конце строки

**Примеры преобразования:**
- `"Code Reviewer"` → `"code_reviewer"`
- `"Custom Agent"` → `"custom_agent"`
- `"Test-Agent 123"` → `"test_agent_123"`
- `"  My Agent  "` → `"my_agent"`
- `"Agent__Name"` → `"agent_name"`
- `"___agent___"` → `"agent"` (удаление подчёркиваний в начале и конце)
- `"agent   name"` → `"agent_name"` (множественные пробелы заменяются на одно подчёркивание)

**Использование преобразованной роли:**
- Преобразованная роль используется для проверки конфликтов между агентами (сравнение происходит по преобразованным ролям)
- Преобразованная роль используется при вызове `invoke_subagent()` (оркестратор должен передавать преобразованную роль)
- Преобразованная роль хранится в runtime конфигурации
- Исходная роль из METADATA сохраняется для отображения в промпте оркестратора (в колонке "Роль" таблицы может отображаться исходная или преобразованная роль, на усмотрение реализации)

**Важно:**
- При проверке конфликтов сравниваются преобразованные роли
- Если две разные исходные роли преобразуются в одну и ту же, это считается конфликтом
- Пример конфликта: `"Code Reviewer"` и `"code_reviewer"` преобразуются в `"code_reviewer"` → конфликт

**INVOCATION CONDITIONS:**
- Описывает, когда оркестратор должен вызывать этот агент
- Эта информация встраивается в промпт оркестратора при обновлении
- Рекомендуется для всех агентов, но не является обязательной

**PROMPT:**
- Содержит системный промпт агента
- Передаётся в `cursor-agent` CLI при вызове через `invoke_subagent()`
- Только эта секция передаётся агенту (без METADATA и INVOCATION CONDITIONS)
- Обязательная секция

### 5.3. Пример полного файла

```markdown
## METADATA

role: code_reviewer_custom
name: Кастомный ревьюер кода
description: Специализированный ревьюер для Python проектов
default_model: claude-sonnet-4-20250514

## INVOCATION CONDITIONS

Используй этого агента для:
- Ревью Python кода
- Проверки соответствия PEP 8
- Анализа сложности кода

## PROMPT

Ты — специализированный ревьюер Python кода.

Твоя задача:
1. Проверять соответствие PEP 8
2. Находить потенциальные баги
3. Предлагать улучшения производительности

[Детальный промпт...]
```

## 6. Разрешение конфликтов ролей

### 6.1. Обнаружение конфликтов

При загрузке динамических агентов система проверяет конфликты в следующем порядке:

1. **Сначала проверяются конфликты между динамическими агентами:**
   - Система сравнивает преобразованные роли всех динамических агентов
   - Если несколько динамических агентов имеют роли, которые преобразуются в одинаковую роль, это считается конфликтом
   - Порядок обработки файлов: алфавитный по имени файла (для детерминированности)
   - **При обнаружении конфликта между динамическими агентами проверка сразу прекращается, ошибка выводится, сервер не запускается**
   - Проверка конфликтов с встроенными агентами выполняется только если нет конфликтов между динамическими

2. **Затем проверяются конфликты между динамическими и встроенными агентами:**
   - Система сравнивает преобразованные роли динамических агентов с ролями встроенных агентов из `agents.yaml`
   - Если преобразованная роль динамического агента совпадает с ролью встроенного агента, это считается конфликтом
   - Проверка выполняется только если нет конфликтов между динамическими агентами

**Важно:**
- При проверке конфликтов сравниваются преобразованные роли (результат алгоритма преобразования из раздела 5.2)
- Если две разные исходные роли преобразуются в одну и ту же, это считается конфликтом
- Пример конфликта: `"Code Reviewer"` и `"code_reviewer"` преобразуются в `"code_reviewer"` → конфликт

### 6.2. Обработка конфликтов

**Если обнаружен конфликт между динамическими агентами:**
1. Система НЕ запускается
2. Выводится ошибка в консоль: `"Role conflict detected: role 'X' is used by multiple dynamic agents in files: file1.md, file2.md"`
3. Пользователь должен исправить конфликт:
   - Изменить роль одного из конфликтующих агентов в соответствующем MD файле
   - Удалить один из конфликтующих MD файлов
4. После исправления пользователь перезапускает сервер

**Если обнаружен конфликт между динамическим и встроенным агентом:**
1. Система НЕ запускается
2. Выводится ошибка в консоль: `"Role conflict detected: role 'X' is already used by a built-in agent"`
3. Пользователь должен исправить конфликт:
   - Изменить роль динамического агента в MD файле
   - Удалить встроенного агента из `agents.yaml` (не рекомендуется)
4. После исправления пользователь перезапускает сервер

**Если конфликтов нет:**
- Система успешно запускается
- Все агенты доступны через `invoke_subagent()`

## 7. Обновление промпта оркестратора

### 7.1. Механизм обновления

**Общий принцип:**
- Промпт оркестратора обновляется в памяти при каждом вызове `get_orchestration_guide()`
- Файл `agents-master/01_orchestrator.md` НЕ изменяется на диске
- Обновление происходит runtime (динамически) на основе текущей конфигурации агентов
- Обновлённый промпт пересчитывается при каждом вызове (кэш не используется)

**Детальный алгоритм обновления:**

1. **При каждом вызове `get_orchestration_guide()`:**
   - Система загружает исходный промпт из файла `agents-master/01_orchestrator.md` (файл перечитывается при каждом вызове для обработки возможных изменений)
   - Система ищет секцию "ДОСТУПНЫЕ АГЕНТЫ" (или аналогичную) в промпте по заголовку уровня 2, содержащему ключевые слова "ДОСТУПНЫЕ АГЕНТЫ" или "AVAILABLE AGENTS" (регистр не важен, case-insensitive поиск)
   - Поиск выполняется по заголовку уровня 2 (`## Заголовок`), содержащему ключевые слова
   - Если секция не найдена, система добавляет новую секцию в конец промпта
   - Система формирует единый список агентов:
     - Сначала встроенные агенты из `agents.yaml` (в порядке, указанном в файле)
     - Затем динамические агенты из MD файлов (в алфавитном порядке по преобразованной роли)
   - Система генерирует таблицу markdown со списком всех агентов (формат описан в разделе 7.2)
   - Система заменяет содержимое секции "ДОСТУПНЫЕ АГЕНТЫ" на сгенерированную таблицу (или вставляет новую секцию, если её не было)
   - Система заменяет всю секцию от заголовка до следующего заголовка уровня 2 (или до конца файла, если секция последняя)
   - Обновлённый промпт НЕ сохраняется в кэше, а пересчитывается при каждом вызове
   - Система возвращает обновлённый промпт оркестратору

2. **Хранение обновлённого промпта:**
   - Обновлённый промпт НЕ хранится в кэше
   - Промпт пересчитывается при каждом вызове `get_orchestration_guide()` на основе актуальной конфигурации агентов
   - Это гарантирует, что список агентов всегда актуален (включая изменения в MD файлах после перезапуска сервера)
   - Обновлённый промпт возвращается как строка, но не сохраняется в объекте конфигурации

3. **Обработка изменений исходного файла:**
   - При каждом вызове `get_orchestration_guide()` файл `01_orchestrator.md` перечитывается с диска
   - Если пользователь вручную изменил секцию "ДОСТУПНЫЕ АГЕНТЫ" в файле, система перезапишет её при следующем вызове `get_orchestration_guide()` (это ожидаемое поведение)
   - Если файл изменён и структура нарушена (например, удалена секция "ДОСТУПНЫЕ АГЕНТЫ"), система:
     - Использует текущую версию файла
     - Если секция "ДОСТУПНЫЕ АГЕНТЫ" не найдена, добавляет её в конец промпта
     - Логирует предупреждение о структурных изменениях (если требуется)
   - Если файл не существует или недоступен, система возвращает ошибку

### 7.2. Формат списка агентов

**Структура таблицы:**
- Все агенты (встроенные и динамические) отображаются в единой таблице markdown
- Нет различий между встроенными и динамическими агентами в промпте
- Формат таблицы аналогичен текущей таблице в `01_orchestrator.md`:

```markdown
## ДОСТУПНЫЕ АГЕНТЫ

| Роль | Имя | Описание | Условия вызова |
|------|-----|----------|----------------|
| analyst | Аналитик | Создаёт технические задания | Для анализа требований и создания ТЗ |
| code_reviewer | Ревьюер кода | Проверяет код на ошибки | Для ревью кода перед мерджем |
| custom_agent | Кастомный агент | Описание кастомного агента | Для задач типа X, когда требуется Y |
```

**Порядок агентов:**
1. Сначала встроенные агенты из `agents.yaml` (в порядке, указанном в файле)
2. Затем динамические агенты из MD файлов (в алфавитном порядке по преобразованной роли)

**Содержимое колонок:**
- **Роль:** преобразованная роль агента (для динамических агентов - результат преобразования из секции METADATA)
- **Имя:** имя агента из метаданных
- **Описание:** описание агента из метаданных
- **Условия вызова:** 
  - Для встроенных агентов: из `agents.yaml` (если указано поле `invocation_conditions` или `conditions`), иначе колонка остаётся пустой
  - Для динамических агентов: содержимое секции `## INVOCATION CONDITIONS` из MD файла (если секция отсутствует, колонка остаётся пустой)

## 8. Парсинг MD файлов

### 8.1. Алгоритм извлечения секций

**Общий принцип:**
- MD файл парсится построчно для поиска секций уровня 2 (`## Заголовок`)
- Секции определяются точным совпадением заголовка (регистр может быть не важен, в зависимости от реализации)
- Содержимое секции извлекается от заголовка до следующего заголовка уровня 2 (`##`) или до конца файла

**Алгоритм извлечения секции PROMPT:**

1. Система читает MD файл построчно
2. Система ищет заголовок уровня 2 `## PROMPT` (регистр не важен, case-insensitive сравнение)
3. Если заголовок найден:
   - Система извлекает всё содержимое от строки после заголовка `## PROMPT` до:
     - Следующего заголовка уровня 2 (`## Заголовок`) - исключая сам заголовок
     - Или до конца файла, если следующего заголовка уровня 2 нет
   - Подсекции внутри PROMPT (например, `### Подраздел`, `#### Подподраздел`) сохраняются как часть промпта
   - Пустые строки в начале и конце извлекаемого содержимого удаляются (trim)
4. Если секция PROMPT не найдена или извлечённое содержимое пусто (после trim), файл считается невалидным

**Алгоритм извлечения секции METADATA:**

1. Система ищет заголовок уровня 2 `## METADATA` (регистр не важен, case-insensitive сравнение)
2. Если заголовок найден:
   - Система извлекает содержимое от строки после заголовка до следующего заголовка уровня 2 или до конца файла
   - Содержимое парсится как YAML-подобный формат (пары `ключ: значение`)
   - Многострочные значения поддерживаются (с отступами)
   - Извлекаются поля: `role`, `name`, `description`, `default_model`
3. Если секция METADATA не найдена или обязательные поля отсутствуют, файл считается невалидным

**Алгоритм извлечения секции INVOCATION CONDITIONS:**

1. Система ищет заголовок уровня 2 `## INVOCATION CONDITIONS` (регистр не важен, case-insensitive сравнение)
2. Если заголовок найден:
   - Система извлекает содержимое от строки после заголовка до следующего заголовка уровня 2 или до конца файла
   - Содержимое сохраняется как есть (markdown текст)
   - Если секция отсутствует, считается, что условия вызова не указаны (не является ошибкой)
3. Если секция не найдена, используется пустая строка

**Валидация формата секций:**

- Заголовки секций должны быть уровня 2 (`## Заголовок`)
- Если секция написана с неправильным уровнем (например, `### METADATA` или `# METADATA`), она не распознаётся
- Если секция написана с опечаткой (например, `## METADAT` вместо `## METADATA`), она не распознаётся
- Если найдено несколько секций с одинаковым названием (например, два `## PROMPT`), используется первая найденная секция, остальные игнорируются
- **Регистр заголовка НЕ важен (case-insensitive сравнение):**
  - `## METADATA`, `## metadata`, `## Metadata`, `## MeTaDaTa` — все распознаются как одна секция
  - `## INVOCATION CONDITIONS`, `## invocation conditions`, `## Invocation Conditions` — все распознаются как одна секция
  - `## PROMPT`, `## prompt`, `## Prompt` — все распознаются как одна секция
- Рекомендуется использовать единообразный формат для читаемости: `## METADATA`, `## INVOCATION CONDITIONS`, `## PROMPT`

**Пример парсинга:**

```markdown
## METADATA

role: custom_agent
name: Кастомный агент

## PROMPT

Ты — кастомный агент.

### Твоя задача

1. Делать X
2. Делать Y

### Дополнительно

Важная информация.

## ДРУГАЯ СЕКЦИЯ

Это содержимое не входит в PROMPT.
```

При извлечении секции PROMPT будет получено:
```
Ты — кастомный агент.

### Твоя задача

1. Делать X
2. Делать Y

### Дополнительно

Важная информация.
```

(Без заголовка `## PROMPT` и без содержимого после следующего заголовка уровня 2)
